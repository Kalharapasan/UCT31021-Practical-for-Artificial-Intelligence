% Task 1: Examples of built-in list operations
% a.
example_length :-
    length([a,b,c,d], Len),
    write('Length of [a,b,c,d] is '), writeln(Len).
% b.
example_append :-
    append([a,b], [c,d], Combined),
    write('Appending [a,b] and [c,d] gives '), writeln(Combined).
% c.
example_memberchk :-
    ( memberchk(b, [a,b,c]) -> write('b is in [a,b,c]') ; write('not found') ),
    nl.
% d.
example_delete :-
    delete([a,b,c,b,d], b, Result),
    write('Removing b from [a,b,c,b,d] gives '), writeln(Result).
% e.
example_union :-
    union([a,b,c], [b,c,d], Union),
    write('Union of [a,b,c] and [b,c,d] is '), writeln(Union).

% f.
example_reverse :-
    reverse([a,b,c,d], Reversed),
    write('Reverse of [a,b,c,d] is '), writeln(Reversed).
% Task 2: Recursive member check
member_recursive(X, [X|_]).
member_recursive(X, [_|T]) :-
    member_recursive(X, T).
% Run all examples
run :-
    writeln('=== Built-in List Operation Examples ==='),
    example_length, nl,
    example_append, nl,
    example_memberchk, nl,
    example_delete, nl,
    example_union, nl,
    example_reverse, nl,

    writeln('=== Recursive Member Check ==='),
    ( member_recursive(b, [a,b,c]) -> writeln('b found in [a,b,c] (recursive)') ; writeln('b not found') ),
    ( member_recursive(x, [a,b,c]) -> writeln('x found in [a,b,c] (recursive)') ; writeln('x not found in [a,b,c] (recursive)') ).

% Task 02

% 01. Define the binary tree structure
tree(
    node(5,
        node(3,
            node(1, nil, nil),
            node(4, nil, nil)),
        node(7,
            node(6, nil, nil),
            node(9, nil, nil))
    )
).

% 02. Breadth-First Search (BFS)
bfs(Tree, Result) :-
    bfs_queue([Tree], [], Result).

bfs_queue([], Acc, Acc).
bfs_queue([nil|Rest], Acc, Result) :-
    bfs_queue(Rest, Acc, Result).
bfs_queue([node(Value, Left, Right)|Rest], Acc, Result) :-
    append(Rest, [Left, Right], NextQueue),
    append(Acc, [Value], NewAcc),
    bfs_queue(NextQueue, NewAcc, Result).

% 03. Depth-First Search (DFS) - Preorder
dfs(Tree, Result) :-
    dfs_stack([Tree], [], Result).

dfs_stack([], Acc, Acc).
dfs_stack([nil|Rest], Acc, Result) :-
    dfs_stack(Rest, Acc, Result).
dfs_stack([node(Value, Left, Right)|Rest], Acc, Result) :-
    append([Value], Acc, NewAcc),
    dfs_stack([Left, Right | Rest], NewAcc, TempResult),
    Result = TempResult.

% Show output
run_demo :-
    tree(MyTree),
    bfs(MyTree, BFS_Result),
    dfs(MyTree, DFS_Result),
    writeln('Tree Structure Loaded.'),
    write('BFS Order: '), writeln(BFS_Result),
    write('DFS Order: '), writeln(DFS_Result).

% Task 03:

%01.
edge(1, 2).
edge(1, 3).
edge(2, 4).
edge(2, 5).
edge(3, 5).
edge(4, 6).
edge(5, 6).

%02.
path(X, Y, [X, Y]) :- edge(X, Y).

path(X, Y, [X|Path]) :-
    edge(X, Z),
    path(Z, Y, Path).

%03.
path_no_cycle(X, Y, Path) :-
    path_helper(X, Y, [X], Path).

path_helper(X, Y, Visited, [X, Y]) :-
    edge(X, Y),
    \+ member(Y, Visited).

path_helper(X, Y, Visited, [X|Path]) :-
    edge(X, Z),
    \+ member(Z, Visited),
    path_helper(Z, Y, [Z|Visited], Path).

%04.
find_paths :-
    write('All paths from 1 to 6:'), nl,
    findall(Path, path(1, 6, Path), Paths),
    print_paths(Paths),
    nl,
    write('Cycle-free paths from 1 to 6:'), nl,
    findall(Path, path_no_cycle(1, 6, Path), GoodPaths),
    print_paths(GoodPaths).

print_paths([]).
print_paths([H|T]) :-
    write(' - '), write(H), nl,
    print_paths(T).
